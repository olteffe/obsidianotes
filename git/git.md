**Удаление из кеша индекса git**

```shell
git rm --cached <file>
git rm -r --cached <folderName> для папки
```
***
**Git создать ветку и переключиться на нее**

```bash
git checkout -b iss53	 или в 2 строки
git branch iss53
git checkout iss53
```
***
**Git добавление в предыдущий коммит**

```bash
git commit --amend
```
***
**Принять участие в работе Open Source проектов на GitHub**

1. Форкаем проект
2. Клоним проект
```bash
git clone github.com/way
``` 
3. Установить связь локальной копии с оригинальным проектом
```bash
git remote add upstream github.com/way
```
Теперь ваша локальная копия проекта связана с двумя репозиториями на GitHub:
- `origin`, который указывает на ваш форк проекта на GitHub. Вы можете читать его, и писать в этот репозиторий.
- `upstream`, который указывает на GitHub-репозиторий основного проекта. Этот репозиторий можно только читать.
4. 
```bash
git checkout master
git pull upstream master && git push origin master
git checkout -b <my branch>
```
В первую очередь мы убеждаемся, что находимся на master-ветке. Затем команда `git pull` синхронизирует нашу локальную копию с основной веткой проекта, а команда `git push` синхронизирует ее с нашим форкнутым проектом на GitHub. Наконец, мы создаем новую ветку `<my branch>`.
5.  Пушим локальную ветку в свой форк
```bash
git push -u origin <my branch>
```
Флаг `-u` связывает эту ветку с удаленной
6.  Переходим в форк на gh и `Compare & pull request` затем `Create pull request`

То же самое с помощью `gh cli`:
```bash
gh repo fork <name repo>
git switch -c <my branch>
```
Делаем полезные изменения, например в README.md
```bash
git push -u origin <my branch>

gh pr create --title "update README.md" --body "Slightly updated Russian README"
```
Ревью кода и успешное принятие вашего PR
***
Вообще есть 2 способа добавить свежие изменения из mainstream в вашу ветку:

Rebase — переносит ваши изменения поверх mainstream. История получается максимально чистая, но коммиты меняются, то есть если кто-то воспользовался вашей веткой, а вы ее поребейсили — у вашего товарища могут возникнуть проблемы.

Merge — выбирая путь merge приходится отказаться от редактирования коммитов и считать, что как только вы набрали git commit — коммит высечен в камне, и рано или поздно окажется в мастере.

Если совсем кратко: при использовании rebase будет чистая история, но нельзя организовать работу нескольких человек над фичей в отдельной ветке. При merge наоборот: любой коммит, косой-кривой, с ошибками и ломающий все на свете навсегда впечатывается в историю но зато несколько человек могут работать над фичей в отдельной ветке.

Правильное использование rebase:
```shell
git fetch # скачиваем изменения с сервера
# надо находиться в ветке, которую вы хотите обновить 
# вместо origin/master нужно вписать вашу mainstream-ветку 
git rebase origin/master # далее, если возник конфликт, исправляем его и делаем 
git add file-with-conflict.go 
git rebase --continue # повторяем до тех пор, пока не появится сообщение 
# Successfully rebased and updated ...
```

Правильное использование merge:
```shell
git fetch # скачиваем изменения с сервера 
# надо находиться в ветке, которую вы хотите обновить 
# вместо origin/master нужно вписать вашу mainstream ветку 
git merge origin/master # далее, если возник конфликт 
git add file-with-conflict.go 
git commit
```
---
